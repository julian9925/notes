{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Welcome to Juian's Note","n":0.5},"1":{"v":"\nThis is my personal knowledge base. It is built using [Dendron](https://wiki.dendron.so/).\n\n這會是中英文夾雜的知識庫\n\n包含\n - 一些讀書心得\n - 一些個人筆記\n - 一些 leetcode 的解題心得\n\n## Lookup\n\nThis section contains useful links to related resources.\n\n- [Getting Started Guide](https://link.dendron.so/6b25)\n- [Discord](https://link.dendron.so/6b23)\n- [Home Page](https://wiki.dendron.so/)\n- [Github](https://link.dendron.so/6b24)\n- [Developer Docs](https://docs.dendron.so/)","n":0.167}}},{"i":2,"$":{"0":{"v":"OpenBmc","n":1}}},{"i":3,"$":{"0":{"v":"web-ui","n":1}}},{"i":4,"$":{"0":{"v":"redfish spec validation","n":0.577},"1":{"v":"\n## Redfish spec 驗證參考\n\nOpenBMC UI 中，有使用到的 api call\n\n- AuthenticanStore\n\t- \n\t- logout\n\t- checkPasswordChangeRequired\n\n\n- GlobalStore\n  - getBmcTime\n\t- getSystemInfo\n\n\n- AssemblyStore\n  - getAssemblyInfo\n\t- updateIdentifyLedValue\n\n\n- BmcStore\n  - getBmcInfo\n\t- updateIdentifyLedValue\n\n\n- ChassisStore\n  - getChassisInfo\n\t- updateIdentifyLedValue\n\n\n- FanStore\n  - getFanInfo\n\n\n- MemoryStore\n  - getDimms\n\t- updateIdentifyLedValue\n\n\n- PowerSupplyStore\n  - getChassisCollection\n\t- getAllPowerSupplies\n\t- getChassisPower\n\n\n- ProcessorStore\n  - getProcessorsInfo\n\t- updateIdentifyLedValue\n\n\n- SensorsStore\n  - getAllSensors\n\t- getChassisCollection\n\t- getSensors\n\t- getThermalSensors\n\t- getPowerSensors\n\n\n- ServerLedStore\n  - getIndicatorLedActiveState\n\t- saveIndicatorLedActiveState\n\n\n- SystemStore\n  - getSystem\n\t- changeIdentifyLedState\n\n\n- DumpsStore\n  - getBmcDumpEntries\n\t- getSystemDumpEntries\n\t- getAllDumps\n\t- createBmcDump\n\t- createSystemDump\n\t- deleteDumps\n\t- deleteAllDumps\n\n\n- EventLogStore\n  - getEventLogData\n\t- deleteAllEventLogs\n\t- deleteEventLogs\n\t- resolveEventLogs\n\t- unresolveEventLogs\n\t- updateEventLogStatus\n\n\n- PostCodeLogsStore\n  - getPostCodesLogData\n\n\n- BootSettingsStore\n  - getBootSettings\n\t- saveBootSettings\n\t- getTpmPolicy\n\t- saveTpmPolicy\n\t- saveSettings\n\n\n- ControlStore\n  - getLastPowerOperationTime\n\t- getLastBmcRebootTime\n\t- rebootBmc\n\t- serverPowerChange\n\n\n- FactoryResetStore\n  - resetToDefaults\n\t- resetBios\n\n\n- FirmwareStore\n  - getActiveBmcFirmware\n\t- getActiveHostFirmware\n\t- getFirmwareInventory\n\t- getUpdateServiceSettings\n\t- setApplyTimeImmediate\n\t- uploadFirmware\n\t- uploadFirmwareTFTP\n\t- switchBmcFirmwareAndReboot\n\n\n- KeyClearStore\n\t- clearEncryptionKeys\n\n\n- VirtualMediaStore\n\t- getData\n\t- mountImage\n\t- unmountImage\n\n\n- PowerControlStore\n\t- getChassisCollection\n\t- getPowerControl\n\t- setPowerControl\n\n\n- CertificatesStore\n  - getCertificates\n\t- addNewCertificate\n\t- replaceCertificate\n\t- deleteCertificate\n\t- generateCsr\n\n\n- LdapStore\n  - getAccountSettings\n\t- saveLdapSettings\n\t- saveActiveDirectorySettings\n\t- addNewRoleGroup\n\t- saveRoleGroup\n\t- deleteRoleGroup\n\n\n- PoliciesStore\n  - getNetworkProtocolStatus\n\t- getBiosStatus\n\t- saveIpmiProtocolState\n\t- saveSshProtocolState\n\t- saveRtadState\n\t- saveVtpmState\n\n\n- SessionsStore\n\t- getSessionsData\n\t- disconnectSessions\n\n\n- UserManagementStore\n  - getUsers\n\t- getAccountSettings\n\t- getAccountRoles\n\t- createUser\n\t- updateUser\n\t- deleteUser\n\t- deleteUsers\n\t- enableUsers\n\t- disableUsers\n\t- saveAccountSettings\n\n\n- DateTimeStore\n\t- getNtpData\n\t- updateDateTime\n\n\n- NetworkStore\n  - getEthernetData\n\t- saveDomainNameState\n\t- saveDnsState\n\t- saveNtpState\n\t- saveIpv4Address\n\t- editIpv4Address\n\t- saveSettings\n\t- saveDnsAddress\n\t- editDnsAddress\n\n\n- PowerPolicyStore\n  - getPowerRestorePolicies\n\t- getPowerRestoreCurrentPolicy\n\t- setPowerRestorePolicy","n":0.076}}},{"i":5,"$":{"0":{"v":"redfish intro","n":0.707},"1":{"v":"\n## Data Model\n\n### Resource\n  A Resource is defined as a single entity. Each resource is strongly typed and defined in a Redfish schema document, identifiable in the response payload by a unique type identifier property.\n\n  The response for a single resource typically contains properties like:\n  \n - @odata.id\n - @odata.type\n - Id\n - Name\n\n  Responses may also contain other properties defined within the schema for that resource type.\n\n### Resource Collections\n  A Resource Collection is a collection of resources share the same schema definition.\n\n  Responses for Resource Collections may contain the following properties:\n - @odata.context\n - @odata.etag\n - Description\n - Members\n - @odata.nextLink\n - Oem\n\n","n":0.098}}},{"i":6,"$":{"0":{"v":"environment setup","n":0.707},"1":{"v":"\n# OpenBmc WebUI 環境設置\n\n## 如何 build OpenBmc 在 ubuntu 64 20.04 上\n\n參照 [官方 OpenBmc 文件](https://github.com/openbmc/openbmc)\n \n 1. 安裝有關套件，以 ubuntu 為例\n ```\n sudo apt install git python3-distutils gcc g++ make file wget \\\n    gawk diffstat bzip2 cpio chrpath zstd lz4 bzip2\n ```\n\n 2. clone OpenBmc code, 到 code 位置 setup\n\n ```\n git clone https://github.com/openbmc/openbmc\n cd openbmc\n . setup romulus //還有其他相關的環境可供部署\n ```\n\n 3. build\n\n `bitbake obmc-phosphor-image`\n\n 4. QEMU running up，下載 qemu 進行安裝\n   參照 [OpenBmc develop 環境設置](https://github.com/openbmc/docs/blob/master/development/dev-environment.md)\n\n  ```\n  wget https://jenkins.openbmc.org/job/latest-qemu-x86/lastSuccessfulBuild/artifact/qemu/build/qemu-system-arm\n  chmod u+x qemu-system-arm\n  ```\n\n 5. image 移到想要位置，對 image 進行 qemu 模擬\n\n ```\n cp ./tmp/deploy/images/romulus/obmc-phosphor-image-romulus.static.mtd ./\n\n qemu-system-arm -m 256 -M romulus-bmc -nographic -drive file=./obmc-phosphor-image-romulus.static.mtd,format=raw,if=mtd -net nic -net user,hostfwd=tcp::2222-:22,hostfwd=tcp::2443-:443,hostname=qemu\n ```\n > Note: 依照 REST, SSH 和 IPMI 在自己的 QEMU session，必須分別把 REST, SSH 和 IPMI 作 port forwarding\n\n ## 如何在 ubuntu 進行 web-ui 開發\n\n 1. clone web-ui vue\n\n ```\n https://github.com/openbmc/webui-vue.git\n ```\n\n 2. 依照 `npm install` 結束後， `npm run serve`\n\n 3. 透過 vscode ssh 至 ubuntu 64 arm 進行開發","n":0.081}}},{"i":7,"$":{"0":{"v":"embedded","n":1}}},{"i":8,"$":{"0":{"v":"Yocto Receipe elements","n":0.577},"1":{"v":"\n## Linux Embedded Necessaries\n\n### Toolchain\n- Compiler and otehr tools needed to create code for your target devices.\n\n### Bootloader\n- The program that initializes the board and loads Linux Kernel.\n\n### Kernel\n- This is the heart of system, managing system resources and interfacing eith hardware.\n\n### Root filesystem\n- Contains the libraries and program that run once the kernel has completed its initialization.\n\n---\n\n## Yocto Project\n\n- Ycoto provides open source, high quality infrastructure and tools to help developers create their own custom Linux distributions for any hardware architecture.\n\n## Advantages of Yocto Project\n\n- Widely Adopted Across the Industry\n\t - Semiconductor, operating system, software, and service vendors exist whose products and services adopt and support the Yocto Project.\n\tEg. Intel, Facebook, arm, Juniper Networks, LG, AMD, NXP, DELL\n\n\n- Architecture Agnostic\n\t- supports Intel, ARM, MIPS, AMD, PPC and other architectures\n\tchip vendors create and supply BSPs that support their hardware\n\tif you have custom silicon, you can create a BSP that supports that architecture\n\tthe Yocto Project fully supports a wide range of device emulation through the Quick EMUlator (QEMU)\n\n\n- Images and Code Transfer Easily\n\t- Yocto Project output can easily move between architectures without moving to new development environments.\n\n\n- Flexibility\n\t- Through customization and layering, a project group can leverage the base Linux distribution to create a distribution that works for their product needs.\n\n\n- Ideal for Constrained Embedded and IoT devices\n\t- Unlike a full Linux distribution, you can use the Yocto Project to create exactly what you need for embedded devices\n\tYou only add the feature support or packages that you absolutely need for the device\n\n\n- Uses a Layer Model\n\t- The Yocto Project layer infrastructure groups related functionality into separate bundles.\n\tYou can incrementally add these grouped functionalities to your project as needed\n\tAllows you to easily extend the system, make customizations, and keep functionality organized.\n\n\n## Pocky\n\n\n- Pocky is a reference distribution of Yocto Project. The word \"reference\" is used to mean \"example\" in this context.\n\n- Yocto project use Poky to build image (Kernel, system, and application software) for targeted hardware.\n\n- At the technical level it is combined repository of its component\n \t- Bitlake\n \t- OpenEmbedded Core\n \t- meta-yocto-bsp\n \t- Documentation\n\n> Note: Poky = Bitbake + Metadata\n\n> Note: Poky does not contain binary files,it is a working example of how to build your own custom Linux distribution from source.\n\n### What is difference between poky and Yocto\n\n- The exact difference between Yocto and Poky is Yocto refers to the organization ( like one would refer to 'canonical', the company behind Ubuntu ), and Poky refers to the actual bits downloaded ( analogous to 'Ubuntu' )\n\n\n## Metadata\n\n- Metadata is collection of\n  - Configuration files (.conf)\n  - Recipes (.bb and .bbappend)\n  - Classes (.bbclass)\n  - Include files (.inc)\n\n## Recipes\n\n- Non-Yocto: A receipe is a set of instructions that describe how to prepare or make something, especially a culinary dish.\n- Yocto: A recipe is a set of instructions that is read and processed by the bitbake.\n\n- Extension od receipe: .bb\n\n- A Receipe describes:\n\t- Where to find the source code\n\t- Which patches to apply\n\t- Configuration options (Library dependencies, compiler flags, etc)\n\t- Install\n\t- License\n\n- Example of a recipe:\n\t- `dhcp_4.4.1.bb`\n\t- `gstreamer1.0_1.16.1.bb`\n\n## Configuration Files\n\n- Files which hold global definitions of varaiables and hardware configuration information.\n- They tell bitbake how to build the software and put into the image to support a specific hardware platform.\n- Extension of configuration files: .conf\n\n- Types:\n  - Machine configuration files\n\t- Distribution configuration options\n\t- Compiler tuning options\n\t- General Common Configuration Options\n\t- USer Configuration Optiopns (local.conf)\n\n## Classes\n\n- Class files are used to abstract common functionality and share it among multiple recipes (.bb) files\n- To use a class, you simply make sure the receipe inherits the class.\n\n- Extension of class files: .bbclass\n\n- They are usually placed in classes directory inside the meta* directory.\n\n- Example of a classes:\n\t- `cmake.bbclass` - Handles cmake in receipes\n\t- `kernel.bbclass` - Handles buliding kernel. Contains code to build all kernel tree.\n\t- `module.bbclass` - Provide support for building out-of-tree Linux Kernel Modules.\n\n## Layers\n\n- A layer is a collection of recipes.\n- A layer is a directory containing recipes, configuration files, classes, etc. (receipe containers)\n\n- Typical naming convention for layers: meta-<layer_name>\n\n- Poky has the following layers: \n\t- meta, meta-poky, meta-yocto-bsp, meta-selftest, meta-skeleton\n\n- Why Layers:\n  -  Layers provide a mechanism to isolate meta data according to functionality, for instance BSPs, distribution configuration, etc.\n\n\t- For instance, you should have a BSP layer, a GUI layer, a distro configuration layer, middleware layer, or an application layer.\n\t- Putting you entire build into one layer limits and complicates fureture customization and maintenance.\n\n\t- Example:\n\t\t- meta-yocto-bsp   -- BSP metadata\n\t\t- meta-pocky\t\t\t -- Distro metadata\n\n\t- Layers allow you to easily add entire set of meta data and/or replace sets with other sets.\n\n\t- meta-pocky, is itself a layer applied on top of the QE-Core metadata layer.\n\n## Which layers are used by Pocky build system?\n\n  BBLAYERS varaible in `build/conf/bblayers.conf` file lists the layers Bitbake tries to find.\n\n  If bblayers.conf file is not present when you start the build, the OpenEmbedded build system will create a default bblayers.conf.sample when you source the oe-init-build-env script.\n\n- command to find out whick layers are present in the build system:\n\t- go to pocky directory\n\t- `source ./oe-init-build-env`\n\t- `bitbake-layers show-layers`\n\n## Image\n\nAn image is the top level receipe, it has a description, a license and inherits from the core-image class.\n\nIt is used alongside the machine definition, machine describes the hardware used and its capabilities\n\nImage is archecture agnostic and defines how the root filesystem is built, with the packages to include and the configuration to apply.\n\n - Command to check the list of available images:\n\t - `ls meta*/recipes*/images/*.bb`\n\n## Package\n\n- A package is a software component that can be installed on a system. Such as file with name `*.rpm` ,`*.ipk` or `*.deb`\n\n- A single recipe can produce multiple packages. All pacakges that a receipe generated are listed in the receipe varaiable.\n\n- Example:\n\t- `dhcp_4.4.1.bb` - dhcp, dhcp-client, dhcp-dev, dhcp-doc, dhcp-server","n":0.032}}},{"i":9,"$":{"0":{"v":"poky","n":1},"1":{"v":"\n## poky source tree\n\n- **poky**\n\t- **bitbake**:\n\n\t\tHolds all Python scripts used by the bitbake command bitbake/bin is placed into the PATH environmental variable so bitbake can be found\n\n\t- **documentation**\n\n\t\tAll documentation sources for the Yocto Project documentation can be used to generate nice PDF\n\n\t- **meta**\n\n\t  Contains the oe-core metadata\n\n\t\t- **meta-poky**\n\n\t\t  Holds the configuration for the Poky reference distribution\tlocal.conf.sample, bblayers.conf.sample are present here\n\n\t\t- **meta-yocto-bsp**\n\n\t\t  Maintains several BSPs such as the Beaglebone, EdgeRouter, and generic versions of both 32-bit and 64-bit IA machines.\n\n\t\t- **meta-skeleton**\n\n\t\t  Contains template recipes for BSP and kernel development\n\n\t- **scripts**\n\n\t  Contains scripts used to set up the environment, development tools, and tools to flash the generated images on the target.\n\n\t- **LICENSE**\n\n\t  The license under which Poky is distributed (a mix of GPLv2 and MIT)","n":0.09}}},{"i":10,"$":{"0":{"v":"Leetcode","n":1}}},{"i":11,"$":{"0":{"v":"javascript","n":1}}},{"i":12,"$":{"0":{"v":"常見考題","n":1},"1":{"v":"\n ## [2754. Bind Function to Context](https://leetcode.com/problems/bind-function-to-context/)\n\n```javascript\n/**\n * @param {Object} obj\n * @return {Function}\n */\nFunction.prototype.bindPolyfill = function(obj) {\n  let fn = this;\n  return function (...args) {\n    return fn.call(obj, ...args); // OR return fn.apply(obj, args);\n  }\n}\n\n```\n\n思路：\n在不能用 bind 的情況下，將 `obj` 帶入 thisArgs 為這 function 可以讀到的 this scope\n\n## [2632.Curry](https://leetcode.com/problems/curry/)\n\n原理：\n將函數的參數傳遞方式彈性運用，像是\n\n```javascript\nfunction sum(a, b, c) {  \n  return a + b + c;\n}\nlet curriedSum = curry(sum);\nalert( curriedSum(1, 2, 3) ); // 6，仍然可以被正常调用\nalert( curriedSum(1)(2,3) ); // 6，对第一个参数的柯里化\nalert( curriedSum(1)(2)(3) ); // 6，全柯里化\n```\n\n思路：\n1. 運用兩層 function\n2. 確認原本 function 的參數長度，如果傳進來的參數長度大於原本的長度，將參數合併重新傳遞給上層 function\n\n```javascript\nvar curry = function(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn(...args);\n    } else {\n      return function(...args2) {\n        return curried(...args, ...args2);\n      };\n    }\n  };\n};\n```\n\n## [2627. Debounce](https://leetcode.com/problems/debounce/)\nGiven a function fn and a time in milliseconds t, return a **debounced** version of that function.\n\n![](/assets/debounce.png)\n\nA **debounced** function is a function whose execution is delayed by t milliseconds and whose execution is cancelled if it is called again within that window of time. The debounced function should also receive the passed parameters.\n\n思路：\n在原本的 setTimeout 被設定後，新的 TimeoutId 會把原本的 TImeoutId 給清除，同樣會給定時間後執行\n\n```javascript\n/**\n * @param {Function} fn\n * @param {number} t milliseconds\n * @return {Function}\n */\nvar debounce = function(fn, t) {\n  let timeoutId;\n  return function(...args) {\n\tif (timeoutId) {\n \t  clearTimeout(timeoutId);\n   }\n   \n   timeoutId = setTimeout(() => fn(...args), t); //notice: must execute fn()\n}\n```\n\n## [2676. Throttle](https://leetcode.com/problems/throttle/)\n\nGiven a function fn and a time in milliseconds t, return a **throttled** version of that function.\nA **throttled** function is first called without delay and then, for a time interval of t milliseconds, can't be executed but should store the latest function arguments provided to call fn with them after the end of the delay.\n\n![](/assets/throttle.png)\n\n思路：\n1. 利用 storedArg 確認 timeoutFunc 是否還需要做遞迴執行, waiting 確認 fn 執行後，再次被呼叫後，是否需要等待\n2. timeoutFunc 用來執行被延遲的 func，如果在 waiting，會等到 waiting 結束後從 storedArg 執行，但如果執行 waiting 後的 func ，又有新的不同 func 進來，確保有被執行到 \n\n\n```javascript\nfunction throttle(fn, t) {\n    let storedArg = null;\n    let waiting = false;\n\n\t// step 2.\n    function timeoutFunc() {\n        if (!storedArg) {\n            waiting = false;\n            return;\n        }\n\n        fn(...storedArg);\n        storedArg = null;\n        setTimeout(timeoutFunc, t);\n    }\n\n\t// step 1.\n    return function(...args) {\n        if (waiting) {\n            storedArg = args;\n            return;\n        }\n\n        fn(...args);\n        waiting = true;\n        setTimeout(timeoutFunc, t);\n    }\n}\n\n\n```\n\n## [2628. JSON Deep Equal](https://leetcode.com/problems/json-deep-equal/description/)\n\n思路：\n1. 檢查是否相等\n2. 如果是其中一個是 null，及早 return false\n3. 利用 String() 判斷, 特例：\n   `String({\"0\":1}) String([1]) => [object object] 1` \n4. 判斷是否為 Array ，再來判斷長度，一樣用遞迴判斷內容是否相等\n5. 判斷是否為 Object，再來判斷 property 長度，一樣用遞迴判斷內容是否相等\n6. 最後 return true\n\n``` javascript\n/**\n * @param {any} o1\n * @param {any} o2\n * @return {boolean}\n */\nvar areDeeplyEqual = function(o1, o2) {\n  if (o1 === o2) return true;\n  if (o1 === null || o2 === null) return false;\n  if (String(o1) !== String(o2)) return false;\n\n  if (typeof o1 !== 'object') {\n    if ( o1 !== o2) {\n      return false;\n    }\n  }\n\n  if (Array.isArray(o1)) {\n    if (o1.length !== o2.length) {\n      return false;\n    }\n\n    for (let i = 0; i < o1.length; i++) {\n      if (!areDeeplyEqual(o1[i], o2[i])) {\n        return false;\n      }\n    }\n  }\n\n  if (typeof o1 === 'object' && o1 !== null) {\n    const keys1 = Object.keys(o1);\n    const keys2 = Object.keys(o2);\n\n    // Check if they have the same number of keys\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n\n    for (let key in o1) {\n      if (!areDeeplyEqual(o1[key], o2[key])) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\n```\n## [2636. Promise Pool](https://leetcode.com/problems/promise-pool/description/)\n\n思路：\n因為 functions 不能用 iteration 的方式，所以用遞迴的方式，每次都把 functions 的第一個 function 執行，並且把剩下的 functions 傳遞給下一次的遞迴\n\n1. 寫出 helper 目的讓 array 用 shift 出第一個 function，並且把剩下的 functions 傳遞給下一次的 helper 遞迴\n2. 將 functions 轉成長度為 function 長度的 array 重複執行 helper\n3. return new Promise.all 結果\n\n```javascript\ntype F = () => Promise<any>;\n\nfunction promisePool(functions: F[], n: number): Promise<any> {\n  async function evaluateFunction(): Promise<any> {\n    if (functions.length > 0) {\n      let f = functions.shift();\n      if (f) {\n        await f();\n        await evaluateFunction();\n      }\n    }\n\n    return;\n  }\n\n  let promises = Array(n).fill(0).map(() => evaluateFunction());\n  return Promise.all(promises);\n};\n```\n\n\n## [2625. Flatten Deeply Nested Array](https://leetcode.com/problems/flatten-deeply-nested-array/description/)\n\n思路：\n1. 輪詢 array\n2. 利用遞迴，如果是 array 就繼續遞迴，如果不是就 push 到 result\n3. n 層解構，每呼叫一自己，n 就減一，直到 n 為 0，就不再遞迴\n4. 如果不是 array 就 push 到 result\n\n```javascript\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\n\nvar flat = function (arr: MultiDimensionalArray, n: number): MultiDimensionalArray {\n\tlet res: MultiDimensionalArray = [];\n\n\tfor(let i = 0; i < arr.length; i++) {\n    if (Array.isArray(arr[i]) && n > 0) {\n      res.push(...flat(arr[i] as MultiDimensionalArray, n -1));\n    } else {\n      res.push(arr[i]);\n    }\n  }\n    \n\treturn res;\n};\n```\n\n#leetcode #javascript","n":0.04}}},{"i":13,"$":{"0":{"v":"algorithm","n":1}}},{"i":14,"$":{"0":{"v":"tree pattern","n":0.707},"1":{"v":"\n## Sliding Window\n\n```javascript\n\nvar slidingWindow = function(s) {\n    const window = new Map();\n    \n    let left = 0, right = 0;\n    while (right < s.length) {\n        let c = s[right];\n        window.set(c, (window.get(c) || 0) + 1);\n        // 增大窗口\n        right++;\n        // 进行窗口内数据的一系列更新\n        ...\n\n        /*** debug 输出的位置 ***/\n        // 注意在最终的解法代码中不要 console.log\n        // 因为 IO 操作很耗时，可能导致超时\n        console.log(\"window: [\" + left + \", \" + right + \")\");\n        /********************/\n        \n        // 判断左侧窗口是否要收缩\n        while (window needs shrink) {\n            // d 是将移出窗口的字符\n            let d = s[left];\n            window.set(d, window.get(d) - 1);\n            // 缩小窗口\n            left++;\n            // 进行窗口内数据的一系列更新\n            ...\n        }\n    }\n}\n```\n\n\n## sliding window 思路\n1、什麼時候該擴大窗口？\n2、什麼時候該縮小窗口？\n3、什麼時候該更新答案？\n\n## 題目\n| **LeetCode**                                                 | **难度** |\n|:------------------------------------------------------------:|:------:|\n| \\| [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | Medium |\n| \\| [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/) | Medium |\n| \\| [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/) | Medium |\n| \\| [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/) | Hard   |\n\n## BST\n\n```javascript\nvar BST = function(root, target) {\n    if (root.val === target) {\n        // 找到目标，做点什么\n    }\n    if (root.val < target) { \n        BST(root.right, target);\n    }\n    if (root.val > target) {\n        BST(root.left, target);\n    }\n};\n\n```\n\n[Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)\n\n注意：\n當到左子樹時，root 應當為所有左子樹最大值，所有右邊都比左大，方為合法  BST\n當到右子樹時，root 應當為所有右子樹最小值，所有左邊都比右小，方為合法  BST\n\n## Binary Tree 基本題\n\nQuick sort 為 binary tree 的 preorder, merge sort 為 binary tree 的 postorder\n\nQuick sort pattern, \n```javascript\nfunction quickSort(nums, lo = 0, hi = nums.length - 1) {\n\tif (lo < hi) {\n\t\tp = partition(nums, lo, hi);\n\t\tquickSort(nums, lo, p);\n\t\tquickSort(nums, p + 1, hi);\n\t}\n}\n```\n\n```javascript\nfunction partition(nums, lo, hi) {\n\tlet piviot = nums[hi];\n\tlet i = lo;\n\tfor (let j = lo; j < hi; i++) {\n\t\tif (nums[lo] < piviot) {\n\t\t\t[nums[lo], nums[hi]] = [nums[hi], nums[lo]];\n\t\t}\n\t\ti++\n\t}\n\n\t[nums[i], piviot] = [piviot, nums[i]];\n\treturn i;\n}\n```\n\n**[104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)**\n\n![](Leetcode%20Pattern/2.jpeg)\n\n#javascript #leetcode","n":0.063}}},{"i":15,"$":{"0":{"v":"Javascript","n":1}}},{"i":16,"$":{"0":{"v":"vanilla","n":1}}},{"i":17,"$":{"0":{"v":"falsy value","n":0.707},"1":{"v":"\n# Javascript difference between null, undefined or undeclared\n\nundefined\n* A variable that has been declared but not assigned a value is undefined.\n* It's the default value of function parameters that are not provided when the function is called.\n* If a function doesn't explicitly return a value, it will return undefined.\n\nundefined is a primitive type , and null is also a primitive type. .To check for it, compare using the strict equality (===) operator or typeof which will give the 'undefined' string. Note that you should not be using the abstract equality operator to check, as it will also return true if the value is null.\n\n`null == undefined` true, `null === undefined` false\n\nA variable that is null will have been explicitly assigned to the null value. It represents no value and is different from undefined in the sense that it has been explicitly assigned\n\nnull:\n* null is an assignment value. It represents the intentional absence of any object value.\n* It needs to be explicitly assigned to a variable.\n\n\n``` javascript\nvar foo;\nconsole.log(foo); // undefined\nconsole.log(foo === undefined); // true\nconsole.log(typeof foo === 'undefined'); // true\n\nconsole.log(foo == null); // true. Wrong, don't use this to check!\n\nfunction bar() {}\nvar baz = bar();\nconsole.log(baz); // undefined\n```\n\nSo, in summary:\n* For **primitives**: Assignment is by value. Modifying one variable doesn't affect others with the original value.\n* For **non-primitives (objects)**: Assignment is by reference. Modifying the object affects all variables pointing to that object, but reassigning one of those variables to a new object doesn't change the others.\n\n\n#Frontend   #javascript","n":0.066}}},{"i":18,"$":{"0":{"v":"eventPropogation","n":1},"1":{"v":"\n## event bubbleing and capturing exection order\n\nBelow is the html example\n\n```html\n<body>\n\t<ul onclick=\"alert('ul')\" id=\"myList\">\n\t\t<li onclick=\"alert('li')\">Item 1</li>\n\t\t<li>Item 2</li>\n\t\t<li>Item 3</li>\n\t</ul>\n</body>\n\n<script>\n  const myList = document.getElementsByTagName('ul')[0];\n\n  myList.addEventListener('click', function(event) {\n     const target = event.target;\n\n     if (target.tagName === 'LI') {\n        let backgroundColor = target.style.backgroundColor;\n        target.style.backgroundColor = backgroundColor === 'yellow' ? '' : 'yellow';\n     }\n  });\n</script>\n```\n\nWhat is the order of execution of the event handlers?\n\nThis is event bubbling. The order of execution is\n1. li -> alert('li')\n2. ul -> alert('ul')\n\nThis is event capturing. Listenter is binded to the ul element.\n3. ul -> event handler change the background color of the li element\n\n- Event Capturing (or \"Capturing Phase\"): This phase is \"top-down\". It starts from the outermost element (typically the document object or the window object) and trickles down to the target element where the event actually occurred.\n\n- Event Bubbling: This phase is \"bottom-up\". After the event has reached its target in the capturing phase, it starts to bubble up from the target element to the outermost element.\n\n## stopPropagation and preventDefault\n\n\n`stopPropagation` and `preventDefault` are both methods available on the event object in the DOM, but they serve different purposes. Here's a breakdown of their differences:\n\n### 1. `stopPropagation`:\n\n- **Purpose**: To prevent the event from propagating (or traveling) through either the capturing or bubbling phases.\n  \n- **Effect**:\n  - In a bubbling phase: If an event handler on a child element calls `stopPropagation`, parent elements will not be notified of the event.\n  - In a capturing phase: If an event handler on a parent element calls `stopPropagation`, child elements will not receive that event during the capturing phase.\n  \n- **Common Use Cases**: \n  - When you want to ensure that only a specific element handles the event and you don't want parent (or child, in capturing mode) elements to know about it.\n  - When nested components might have conflicting event handlers, and you want to ensure only one of them is executed.\n\n### 2. `preventDefault`:\n\n- **Purpose**: To prevent the browser's default behavior associated with the event.\n  \n- **Effect**: Stops the default action associated with the event from occurring. For example:\n  - Clicking a link: By default, it navigates to the link's href. Using `preventDefault` will stop the navigation.\n  - Submitting a form: By default, it sends the form data to the server. Using `preventDefault` will stop the form submission.\n  \n- **Common Use Cases**: \n  - When you want to replace the default behavior with custom behavior. For instance, you might want to use AJAX to submit a form instead of the regular form submission.\n  - Preventing any unwanted default actions while still allowing the event to propagate through the DOM.\n\n### In summary:\n\n- `stopPropagation` is about controlling the flow of the event through the DOM tree.\n- `preventDefault` is about controlling the browser's default behavior for the event.\n\nThey can be used independently or together, depending on the situation. For example, in a form's submit event handler, you might want to validate the form data using JavaScript and, if validation fails, both prevent the form from submitting (`preventDefault()`) and also stop any other submit handlers from being notified (`stopPropagation()`).","n":0.045}}},{"i":19,"$":{"0":{"v":"clousure exam","n":0.707},"1":{"v":"\n# Clousure 考題\n\nclousure 考題：將 setTimeout 時間順序轉為循序執行，利用 clousure 包裝\n\n```javascript\nconst timerA = (callback) => setTimeout(() => callback('a'), 500);\nconst timerB = (callback) => setTimeout(() => callback('b'), 200);\nconst timerC = (callback) => setTimeout(() => callback('c'), 300);\n\n// let setTimeout callback executed sequentially\nfunction promiseCall(func, callback) {\n\treturn new Promise((resolve) => {\n    func((v) => {\n      callback(v);\n      resolve();\n    })\n\t});\n}\n\ndoByOrder(console.log);\n// should return a -> b -> c\nasync function doByOrder(callback) {\n  // await promiseCall(timerA, callback);\n  // await promiseCall(timerB, callback);\n  // await promiseCall(timerC, callback);\n\n  promiseIterable([\n    {func: timerA, callback},\n    {func: timerB, callback},\n    {func: timerC, callback}\n  ])\n}\n\n// doByOrder iterable\n\nasync function promiseIterable(callbackObject) {\n  for (let item of callbackObject) {\n    const { func, callback } = item\n    await promiseCall(func, callback);\n  }\n}\n```","n":0.098}}},{"i":20,"$":{"0":{"v":"classConstructor","n":1},"1":{"v":"\n# Javascript class do what\n\n預期這段會執行什麼？\n\n```javascript\nlet f = function () {\n  this.a = 1;\n  this.b = 2;\n};\n\nlet proto1 = f();\nconsole.log(proto1.a);\n```\n\nnew 做了什麼事情\n\n* **創建一個新的物件**：new 運算符創建一個全新的、空的 JavaScript 物件 {} 實體。\n* **設定原型**：新物件的 Prototype（一個隱藏的內部屬性）被設定為物件的原型屬性。換句話說，新物件從建構函數的原型中繼承。\n* **執行建構函數**：帶有指定參數的建構函數（例如 new f() 中的 f）被調用，並將 this 設定為新創建的物件。這一步是物件初始化的地方，可以添加屬性，附加方法等等。\n* **返回創建的物件**：如果建構函數沒有顯式地返回一個物件（return { /*...*/ }），那麼由 new 創建的新物件將自動被返回。然而，如果建構函數確實返回一個物件，則將返回該物件，而不是新創建的物件。\n\n``` javascript\nlet f = function () {\n  this.a = 1;\n  this.b = 2;\n};\n\nlet proto1 = f();\nconsole.log(proto1.prototype);\n\nlet proto1 = new f();\nconsole.log(proto1.__proto__);\n\nconsole.log(proto1.getPrototypeOf(proto1));\n\nconsole.log(Object.getPrototypeOf(proto1));\n```\n\n物件本身沒有 prototype 屬性，只有函數有 prototype\n\n在 JavaScript 中實現了「第一類函數」（First-Class Function）的特性，這意味著函數可以作為參數傳遞給其他函數，可以從其他函數返回，也可以被賦值給變量，或者作為物件的屬性。函數還有一些其他的特性，比如擁有一個 prototype 屬性（只有函數才有這個屬性），可以被用作建構函數來創建新的物件\n\n在 JavaScript 中，函數也是物件，所以 Object 事實上就是一個特殊的函數，可以用來創建新的物件或者返回已經存在的物件的參考。由於 Object 是一個函數，它自然地擁有 prototype 屬性。這個 prototype 屬性是一個物件，包含了所有由 Object 建構函數創建的物件所繼承的屬性和方法，如 Object.prototype.hasOwnProperty、Object.prototype.toString 等。\n\n最安全的繼承方法\n\n```\nlet SuperClass = function() {\n    this.a = 1;\n    this.b = 2;\n}\n\nlet SubClass = function() {\n    superClass.call(this);\n}\n\nSubClass.prototype = Object.create(SuperClass.prototype);\nSubClass.prototype.constructor = SubClass;\n\n```\n\n\n![](/assets/prototype_chain.drawio.png)\n\n#javascript","n":0.1}}},{"i":21,"$":{"0":{"v":"library","n":1}}},{"i":22,"$":{"0":{"v":"xterm","n":1},"1":{"v":"\n## xterm 踩雷經驗\n### 在使用 xterm 的時候，遇到一些問題，這邊做一些紀錄\n\n- **當使用 attachCustomKeyEventHandler 時，_絕對_ 要 return true/false**\n\n\n  會註冊成 `_customKeyEventHandler`，並在 `_keyDown, _keyUp, _keyPress` 中被呼叫，  \n  並以 `if (this._customKeyEventHandler(ev))` 來判斷是否要繼續處理 key event\n\n[CodeLink](https://github.com/xtermjs/xterm.js/blob/6e351dd4ac23235c587dbf4af4cac737965cb7cd/src/browser/Terminal.ts#L1102)\n\n```typescript\nprotected _keyPress(ev: KeyboardEvent): boolean {\n    let key;\n\n    this._keyPressHandled = false;\n\n    if (this._keyDownHandled) {\n      return false;\n    }\n\n    if (this._customKeyEventHandler && this._customKeyEventHandler(ev) === false) {\n      return false;\n    }\n...\n}\n```\n\n  如果沒有 return true/false，會導致 key event 會被繼續傳遞，而且會將原生事件 cancel，  \n  導致其他的 xterm key event handler (_keyDown, _keyUp, _keyPress, ...) 也會被觸發\n\n\n- 有自己的 cancel function 會在某些地方被呼叫，導致 key event 被 cancel\n\n[CodeLink](https://github.com/xtermjs/xterm.js/blob/6e351dd4ac23235c587dbf4af4cac737965cb7cd/src/browser/Terminal.ts#L1306)\n\n```typescript\n  // TODO: Remove cancel function and cancelEvents option\n  public cancel(ev: Event, force?: boolean): boolean | undefined {\n    if (!this.options.cancelEvents && !force) {\n      return;\n    }\n    ev.preventDefault();\n    ev.stopPropagation();\n    return false;\n  }\n}\n```\n\n\n","n":0.098}}},{"i":23,"$":{"0":{"v":"Vue","n":1}}},{"i":24,"$":{"0":{"v":"Reactivity API","n":0.707},"1":{"v":"\n# Vue - Reactivity API\n\n## Ref\n\n- ref can use both primitive value and objects\n\n```javascript\n<script setup>\nimport { ref } from 'vue'\n\nconst numberRef = ref(0);           // OK\nconst objectRef = ref({ count: 0 }) // OK\n</script>\n\n<template>\n\t{{ numberRef.value }}\n</template>\n```\n\n### watch\n\n\n## Reactive","n":0.164}}},{"i":25,"$":{"0":{"v":"原則","n":1}}},{"i":26,"$":{"0":{"v":"工作與生活","n":1},"1":{"v":"\n# 介紹 原則 - 工作與生活 讀書心得","n":0.408}}},{"i":27,"$":{"0":{"v":"第一章","n":1},"1":{"v":"\n# 第一章. 擁抱現實，沈著應對\n藉由學習，可以改變習慣，最後體驗到與「跑步者的愉悅感」如出一轍的「錯誤學習者的愉悅感」\n\n## 1.1 當個超現實主義者\nA. 夢想 + 現實 + 決心 = 成功的人生\n\n## 1.2 事實 ——— 或者更確切的說，就是對現實有精準了解 ——— 是任何良好結果不可或缺的基礎\n## 1.3 態度要極度開放，極度透明\nA. 態度要極度開放，極度透明，這對增進快速學習和有效改變來說彌足珍貴\n\n* 抱持極度開放態度，可以提高這個回饋機制的效率\n* 你的態度越開放，越不可能欺騙自己\n* 必須要卸下心防，勇於接受別人批評\n* 如果你不開誠布公，就學不到東西\n\nB. 不要在意別人得眼光，讓他阻礙你成功\n\n我講的是分享對彼此以及現實的看法。經歷這種極度真實和極度透明，對於我的決策和人際關係改善有多大的幫助。\n\nC. 擁抱極度真實與極度透明使工作和人際關係更有意義\n\n## 1.4 向大自然學習現實如何運作\n1. 由上往下：試著找出一體適用的法則 / 規律 （==藉由理論了解==）\n2. 由下往上：研究每個具體的案例以及其適用的守則 / 法則。如：小麥的市場或使鴨子異於其他物種的 DNA 序列的特定法則 （==支持理論證明的辯證==）\n\nA. 不要固執己見，堅信事情「應該」如何，不然會錯失了解真實狀況的機會\n不要讓偏見妨礙我們的客觀判斷\n\n* 大自然對於「好」的定義，似乎對整體有利，並盡可能使之完美\n\nB. 一定要符合現實的法則，並對整體的進化作出貢獻，才能算是「好」事 ；那也是最值得做的事。 \n\nC. 演化是宇宙中唯一最強大的力量 ；唯有它是永恆的，它推動一切\n\n* 演化包括不斷的適應 / 發明，適應 / 發明帶來即時的好處，但價值不斷下降，這份痛苦引發重新適應和重新發明\n\n* 如果大自然都完美無缺，就不會進化\n\n* 演化週期是連續、以合乎邏輯的方式展開，往往是自我強化  ( self-reinforcing) 的循環。 \n\n## 1.5 進化是人生最大的成就和最大的回報\n（a）誘因和互動，導致個人追求自身利益，同時促進整體進步\n（b）自然選擇的過程\n（c）快速的實驗和適應\n\nA. 個人的誘因必須和群體目標一致\nB. 現實的優化是為了整體 —— 不是為了個體\nC. 透過快速嘗試錯誤來適應生存環境，難能可貴\n\n* 記憶式學習法 ( 透過自己的意識儲存訊息，日後才能回憶)\n* 潛意識學習法 ( 從經驗中獲取的知識，從來沒有進入我們的意識，會影響我們的決定 )\n* 未經思考的學習法，物種適應編碼的 DNA 改變\n\nD. 知道你既舉足輕重，也微不足道 —— 並決定你想成為什麼樣的人\nE. 你將來是什麼樣的人，取決於你看事情的角度\n\n我現在人生目標只要進化，以及為進化略盡錦薄之力\n\n# 1.6 了解大自然給我們的現實教訓\n\nA. 盡可能將你的進化論發揮到極致\n\n* 耗費心力追求才到手的滿足感，比不上==把事情做好所帶來的成就感==\n\n* 一般心智健康的人會開始求新求變，或者從老東西中尋求新深度，這個過程會讓人變得更強大。佛洛伊德：「愛與工作是人性的基石」\n\nB. 記住 「一分耕耘，一分收穫」\nC. 為了得到力量，必須把自己逼向極限，然而挑戰極限是痛苦的，這是自然的基本規律\n\n人類需要困境，困境是心裡健康必須之物\n\n\n# 1.7 痛苦 + 反省 = 進步\n* 每次面對心裡的痛苦，能夠痛定思痛而不是逃避，結果就是快速學習 / 進化。\n\n* 如果你不經歷失敗，你不會挑戰極限，不挑戰極限，不會發揮潛力。挑戰極限有時成功有時失敗，無論成功或失敗都有點收獲。如果適合你，可能會讓你興奮到極點，甚至讓你上癮。\n\n* 人生大多數的事情都是「情景再現」。你越升級，就越能有效的認清現實，幫助你達到目標。原本千絲萬縷，理不清頭緒的複雜問題就變得更簡單。\n\nA. 干預承受痛苦，而不是逃避\n\n* 到達新境界，意思是會迷上：\n  * 確認、接受和學習處理你的弱點\n  * 寧願你周圍的人對你說實話，也不願面對你的負面想法\n  * ==作你自己，軟弱的時候，不要裝堅強==\n\nB. 擁抱「嚴格的愛」( Tough Love)\n\n* 最終能能不能成功，取決於你對這個事實的體認，即使在痛苦的當下覺得人生無望\n\n## 1.8 權衡後續和更後續的結果\n\n## 1.9 為結果負責\n\n* 無論人生有什麼際遇，如果你為自己的決定負責，不怨天尤人，比較可能取得成功並找到幸福。心裡學家稱為「內部控制點  (internal focus of control) 」。研究也一致發現，那些擁有內部控制的人，表現勝過那些沒有的。\n  * 負責任 <-> 受害者\n\n## 1.10 從更高層次看這部機器\n\nA. 把自己想像成一台機器內運作的機器，並且知道你有能力改變機器，進而產生更好的結果。 \n\n* 你的機器，包括設計 (必須完成的事情)，與一個團隊 (完成指定任務的人)\n\nB. 將操作的結果和定好的目標作比較，可以確定如何修訂你的機器\n\nC. 區分擔任機器設計師的你和機器操作員的你\n\n* 做一個掌握自己人生的優秀設設計師 / 管理人，要比做一個優秀操作員重要的多，想要成功，「設計師 / 管理人的你」必須客觀看待「操作員的你」的真實性格。\n\nD. 大多數的人犯的最大錯誤就是無法客觀的看待自己和別人，導致他們一次又一次碰撞自己和別人的弱點\n\nE. 成功的人能夠超越自我、客觀地看待事物，並管理這些事物來塑造改變\n\n* 發現自己不擅長做某件事，不應該覺得不安，反倒應該高興，並妥善處理，達成願望的機會將會增加。( 知道自己的盲點 )\n\n* 你需要克服這種種情緒，不需要把奮鬥掙扎看成負面的事情\n\n遇到你的缺點，你有四種選擇：\n\n* 你可以否認 ( 這是大多數人的作法 )\n* 你可以接受，並努力改進，嘗試把弱點變成強項 ( 成功與否取決於改變的能力 ) \n* 你可以以接受你的弱點，並且想辦法繞路。\n* 或者，你可以改變正在追求的目標。\n\n如果能夠成功，這可能是最佳選擇。\n\nF. 你的弱項要找這方面有專長的人來幫你，無論如何，截長補短是你應該培養的一門重要技能，因為它會幫你建立起防護欄，防止你做不該做的事\n\nG. 因為人很難客觀看待自己，所以需要仰賴他人的意見和完整證據\n\nH. 你只要心態夠開放包容，而且有決心，幾乎可以心想事成\n\n1. 別把你希望的真實情況，與真正的真實情況搞混了\n2. 別擔心面子問題，而要擔心不能達成目標\n3. 相對於後續和更後續的後果，不要過度重視直接後果\n4. 別讓痛苦阻礙進步\n5. 壞的結果只能怪自己，不能歸咎別人\n\n#book/讀書心得/原則-生活和工作\n\n","n":0.079}}}]}
